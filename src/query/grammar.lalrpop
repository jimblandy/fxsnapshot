// -*- mode: rust -*-

use query::ast::{denoted_string,
                 denoted_regex,
                 Expr,
                 NullaryOp,
                 Predicate,
                 UnaryOp,
                 PredicateOp};
use regex;

grammar;

pub Query: Expr = {
    <Expr<"">>,
}

// There are two flavors of expressions: Expr<""> is the full expression
// grammar, while Expr<"No Parens"> excludes parenthesized expressions. The
// latter is used for implicit equality predicates, like the "5" in "id: 5".
// Because predicates can be parenthesized too, there is no actual change to the
// set of strings accepted; the conditional simply tells LALRPOP that it can
// parse "(5)" in "id: (5)" as a predicate, not an expression, while still
// parsing it as an expression in "id: ((5))".

Expr<P>: Expr = {
    <PrimaryExpr<P>>,
    <e: Expr<P>> <op: UnaryOp> => Expr::Unary(Box::new(e), op),
    <stream: Expr<P>> <op: PredicateOp> <predicate: Predicate> =>
        Expr::Predicate(Box::new(stream), op, predicate),
    <stream: Expr<P>> "{" <predicates: Comma<Predicate>> "}" => {
        Expr::Predicate(Box::new(stream), PredicateOp::Filter,
                     Predicate::And(predicates))
    }
};

PrimaryExpr<P>: Expr = {
    // Number literal.
    <n: r"0x[0-9a-fA-F]+"> => Expr::Number(u64::from_str_radix(&n[2..], 16).unwrap()),
    <n: r"[0-9]+"> => Expr::Number(str::parse(&n).unwrap()),

    // String literal.
    <n: r#""([^\\"]|\\.)*""#> => Expr::String(denoted_string(&n[1..n.len() - 1])),

    "[" <elts: Comma<Expr<"">>> "]" => Expr::StreamLiteral(elts),
    <Nullary> => Expr::Nullary(<>),

    // Grouping. Conditional to avoid ambiguity with predicates.
    "(" <e: Expr<"">> ")" if P != "No Parens" => e,
};

Nullary: NullaryOp = {
    "root" => NullaryOp::Root,
    "nodes" => NullaryOp::Nodes,
};

UnaryOp: UnaryOp = {
    "first" => UnaryOp::First,
    "edges" => UnaryOp::Edges,
    "paths" => UnaryOp::Paths,
};

PredicateOp: PredicateOp = {
    "find" => PredicateOp::Find,
    "until" => PredicateOp::Until,
};

Predicate: Predicate = {
    <PrimaryPredicate>,
    <left: Predicate> "||" <right: PrimaryPredicate> => {
        match left {
            Predicate::Or(mut predicates) => {
                predicates.push(right);
                Predicate::Or(predicates)
            }
            _ => Predicate::Or(vec![left, right])
        }
    },
    <left: Predicate> "&&" <right: PrimaryPredicate> => {
        match left {
            Predicate::And(mut predicates) => {
                predicates.push(right);
                Predicate::And(predicates)
            }
            _ => Predicate::And(vec![left, right])
        }
    }
};

PrimaryPredicate: Predicate = {
    <PrimaryExpr<"No Parens">> => Predicate::Expr(Box::new(<>)),
    <id: r"[a-zA-Z_][a-zA-Z0-9_]+"> ":" <predicate: PrimaryPredicate> =>
        Predicate::Field(id.to_owned(), Box::new(predicate)),
    <r: r"/([^\\/]|\\.)*/"> => Predicate::Regex(regex::Regex::new(&denoted_regex(&r[1..r.len()-1])).unwrap()),
    <r: r"#/([^/]|/[^#])*/#"> => Predicate::Regex(regex::Regex::new(&r[2..r.len()-2]).unwrap()),
    "ends" <p: PrimaryPredicate> => Predicate::Ends(Box::new(p)),
    "any" <p: PrimaryPredicate> => Predicate::Any(Box::new(p)),
    "all" <p: PrimaryPredicate> => Predicate::All(Box::new(p)),
    "!" <p: PrimaryPredicate> => Predicate::Not(Box::new(p)),
    "(" <p: Predicate> ")" => p,
};

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};
