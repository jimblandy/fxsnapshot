// -*- mode: rust -*-

use query::ast::{denoted_string,
                 denoted_regex,
                 Expr,
                 NullaryOp,
                 Predicate,
                 UnaryOp,
                 StreamBinaryOp};
use regex;

grammar;

pub Expr: Expr = {
    <PrimaryExpr>,
    <e: Expr> <op: UnaryOp> => Expr::Unary(op, Box::new(e)),
    <stream: Expr> <op: StreamBinaryOp> <predicate: Predicate> =>
        Expr::Stream(op, Box::new(stream), predicate),
    <stream: Expr> "{" <predicates: Comma<Predicate>> "}" => {
        Expr::Stream(StreamBinaryOp::Filter, Box::new(stream),
                     if predicates.len() == 1 {
                         { predicates }.pop().unwrap()
                     } else {
                         Predicate::And(predicates)
                     })
    }
};

PrimaryExpr: Expr = {
    // Number literal.
    <n: r"0x[0-9a-fA-F]+"> => Expr::Number(u64::from_str_radix(&n[2..], 16).unwrap()),
    <n: r"[0-9]+"> => Expr::Number(str::parse(&n).unwrap()),

    // String literal.
    <n: r#""([^\\"]|\\.)*""#> => Expr::String(denoted_string(&n[1..n.len() - 1])),

    "[" <elts: Comma<Expr>> "]" => Expr::StreamLiteral(elts),
    <Nullary> => Expr::Nullary(<>),
};

Nullary: NullaryOp = {
    "root" => NullaryOp::Root,
    "nodes" => NullaryOp::Nodes,
};

UnaryOp: UnaryOp = {
    "first" => UnaryOp::First,
    "edges" => UnaryOp::Edges,
    "paths" => UnaryOp::Paths,
};

StreamBinaryOp: StreamBinaryOp = {
    "find" => StreamBinaryOp::Find,
    "until" => StreamBinaryOp::Until,
};

Predicate: Predicate = {
    <PrimaryPredicate>,
    <left: Predicate> "||" <right: PrimaryPredicate> => {
        match left {
            Predicate::Or(mut predicates) => {
                predicates.push(right);
                Predicate::Or(predicates)
            }
            _ => Predicate::Or(vec![left, right])
        }
    }
};

PrimaryPredicate: Predicate = {
    <PrimaryExpr> => Predicate::Expr(Box::new(<>)),
    <id: r"[a-zA-Z_][a-zA-Z0-9_]+"> ":" <predicate: PrimaryPredicate> =>
        Predicate::Field(id.to_owned(), Box::new(predicate)),
    <r: r"/([^\\/]|\\.)*/"> => Predicate::Regex(regex::Regex::new(&denoted_regex(&r[1..r.len()-1])).unwrap()),
    <r: r"#/([^/]|/[^#])*/#"> => Predicate::Regex(regex::Regex::new(&r[2..r.len()-2]).unwrap()),
    "ends" <p: PrimaryPredicate> => Predicate::Ends(Box::new(p)),
    "!" <p: PrimaryPredicate> => Predicate::Not(Box::new(p)),
    "(" <p: Predicate> ")" => p,
};

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};
