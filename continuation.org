Git is the backtrace; this is the continuation.

% = < 10 min
%% = 1-8 hr
%%% = 1-5 days
%%%% = big

* closure
- [ ] typing the run-time environment:
  - [ ] `Plan` generic over environment type passed to `Run`
  - [ ] types implement `Plan` conditionally on the environment giving them what
        they need: CoreDump access, lexical access
- [ ] CaptureMap::lambdas needs to be a Vec, with each lambda guaranteed to
  appear before all lambdas it encloses.
- [ ] CaptureMap::lambdas needs to record the parent lambda id, as well.
- [ ] Build ClosureLayouts from from CaptureMap.
- [ ] Thread an environment type through all planning functions
- [ ] Plan lambda, app, var as directed by ClosureLayouts

* internal cleanups
- [ ] %% use interned atoms for identifiers, instead of strings (crate string_cache?)
- [ ] %% Change `Stream<'a>` to `Stream<T>`, make `Stream` independent?
- [ ] %% Change `TryUnwrap` to `FromValue`? so you'd write `Stream<'a>::from_value`?
- [ ] %% Common `BoxedClone` trait for `ClonableStream` and `ClonableCallable`?
- [ ] %% trait for structs from which we can fetch fields by name?
- [ ] %% rearrange into parse, analyze, plan; put `Plan` and `Globals` in `query/mod.rs`.
- [ ] %%% finish fallible-iterator
- [ ] %%% can we specialize some plans to the value types they produce?
- [ ] %%% update dependencies to avoid compiling expensive crates multiple times

* language features
- [ ] %% map - followed by Suffix!
- [ ] %% distinguish 'shortestPaths', 'allPaths'
- [ ] %% pathsfrom
- [ ] %% bug: `paths` assumes core dump edges and id's are all well-formed;
  BreadthFirst should implement FallibleIterator
- [ ] %% avoid exposing hash table nondeterminism (just keep a sorted list of ids)
- [ ] %% How to turn a list of edges into a list of the nodes referred to? (map?)
- [ ] %% tail recursion, by adding a trampoline variant to the `ClonableCallable::call` return type
- [ ] %%% closures
- [ ] %%% should paths be their own type? might be nice
- [ ] %%% nicknames for nodes/edges
- [ ] %%% save previous results for use in future queries, `Out[1] = ...`
- [ ] %%% print closures helpfully
- [ ] %%%% top-level definitions
- [ ] %%%% files, modules
- [ ] %%%% better layout / pretty-printing
- [ ] %%%% static type checking
  - [ ] %%%% explicit types on closure arguments
  - [ ] %%%% homogeneous streams

* performance
- [ ] %% put expensive streams on their own threads
- [ ] %%% Could some Streams be double-ended?
  HashMap::Iter isn't double-ended, so iterating over nodes couldn't be, unless
  we were using a sorted id list. Order of 'edges' is meaningless. bfs can't.
  But literals and paths are ordered. Should compare execution time of 'root
  paths ends id: 0x7f412ebb2040' with and without, since that ends up actually
  drawing all elements from each path, without double-endedness.
- [ ] %%% Can EqualPredicate cache its given value? (A 'once_cache' in the global environment?)
- [ ] %%% specialize to avoid dynamic dispatch for constants and variable references
      (once we can actually write code large enough to benchmark)

* error handling
- [ ] %%% report errors from lexing (denoted_regex, denoted_string)
- [ ] %%% source positions
- [ ] %%% improved output formats for values, more recognizable for general users

* command-line usability
- [ ] %% Operate directly on compressed files. However, decompressing a 13MiB
  snapshot takes about 0.3s, so it's probably nice to retain the ability to
  operate on uncompressed files by just mapping them into memory.
- [ ] %% publish as crate

* ideas that need development
- set operations: union, intersection, subtract - need Eq, Hash
- grouping, sorting - need Ord
- dominator trees
- specify our own trait for formatting values?
