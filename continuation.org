Git is the backtrace; this is the continuation.

* small
- [ ] "grammar.lalrpop" is a redundant name
- [ ] improved output formats for values, more recognizable for general users
- [ ] better layout / pretty-printing
- [ ] lambda
- [ ] map
- [ ] pathsfrom
- [ ] pre-box Predicates, simplify actions in Predicate
- [ ] bug: `paths` assumes core dump edges and id's are all well-formed;
  BreadthFirst should implement FallibleIterator
- [ ] avoid exposing hash table nondeterminism
- [ ] Change `Stream<'a>` to `Stream<T>`, make `Stream` independent?
- [ ] Change `TryUnwrap` to `FromValue`? so you'd write `Stream<'a>::from_value`?
- [ ] publish as crate
  - [ ] publish new fallible-iterator
  - [ ] remove all git dependencies
- [ ] How to turn a list of edges into a list of the nodes referred to?
- [ ] put expensive streams on their own threads
- [ ] Could some Streams be double-ended? HashMap::Iter isn't double-ended, so
  iterating over nodes couldn't be. Order of 'edges' is meaningless. bfs can't.
  But literals and paths are ordered. Should compare execution time of 'root
  paths ends id: 0x7f412ebb2040' with and without, since that ends up actually
  drawing all elements from each path, without double-endedness.
- [ ] can we specialize some plans to the value types they produce?
- [ ] closures and variables
- [ ] Can EqualPredicate cache its given value? (A 'once_cache' in the lexical environment?)
- [ ] definitions
- [ ] read queries from files
- [ ] static type checking
  - [ ] explicit types on closure arguments
  - [ ] homogeneous streams
- [ ] source positions
- [ ] specialize to avoid dynamic dispatch for constants and variable references
      (once we can actually write code large enough to benchmark)
- [ ] trait for structs from which we can fetch fields by name?
- [ ] specify our own trait for formatting values?
- [ ] Use From<&[u8]> instead of FromDumpBytes?

* medium

- dominator trees?

- A patch to make `fxsnapshot` operate directly on a compressed file would be
welcome. However, decompressing a 13MiB snapshot takes about 0.3s, so it's
probably nice to retain the ability to operate on uncompressed files by just
mapping them into memory.

- set operations: union, intersection, subtract

- grouping, sorting

- This query language resembles [LINQ][linq].

[linq]: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/basic-linq-query-operations

